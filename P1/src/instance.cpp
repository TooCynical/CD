#include "instance.hpp"

using namespace std;

Instance::Instance(int n, int **term_locs) {
    _n_terminals = n;
    SetXYZ(term_locs);
    SetVertices();
    SetHananGrid();

    SetTerminals(term_locs);

    SetNeighbours();

    cout << "Generated " << n <<" terminals.\n";
    cout << "Generated " << _V.size() << " vertices." << "\n";
    cout << "Hanan grid is of dimensions " << _nx << ", " << _ny << ", " << _nz << "\n";
    
    cout << "Vertices: \n";
    PrintVertices();

    cout << "Terminals: \n";
    PrintTerminals();

    cout << "\n";
    _hanan_grid[1][0][1]->PrintNeighbours();
}

/* Find all terminals in _V to save specific references to them. */
Result Instance::SetTerminals(int **term_locs) {
    _terminals = (Vertex**) calloc(_n_terminals, sizeof(Vertex*));
    
    /* This is currently O(|Terminals|)*O(|V|), could be faster */
    for (int i = 0; i < _n_terminals; i++) {
        for(int j = 0; j < _n_vertices; j++)
        if (_V[j]->HasCoords(term_locs[i][0], term_locs[i][1], term_locs[i][2]))
            _terminals[i] = _V[j];
    }
    return SUCCESS;
}

/* Set all x,y,z values appearing in terminal locations 
 * for use in finding the Hanan grid. Save how many different
 * x, y, z values were found respectively. */
Result Instance::SetXYZ(int **term_locs) {
    for (int i = 0; i < _n_terminals; i++) {
        _x_values.insert(term_locs[i][0]);
        _y_values.insert(term_locs[i][1]);
        _z_values.insert(term_locs[i][2]);
    }

    _nx = _x_values.size();
    _ny = _y_values.size();
    _nz = _z_values.size();

    return SUCCESS;
}

/* Create all vertices in the Hanan grid generated by the terminals
 * and add references to them to _V. */
Result Instance::SetVertices() {
    set<int>::iterator it_x, it_y, it_z;
    
    for (it_x = _x_values.begin(); it_x != _x_values.end(); it_x++) {
        for (it_y = _y_values.begin(); it_y != _y_values.end(); it_y++) {
            for (it_z = _z_values.begin(); it_z != _z_values.end(); it_z++) {
                _V.push_back(new Vertex(*it_x, *it_y, *it_z));
            }
        }
    }

    _n_vertices = _V.size();
    return SUCCESS;
}

/* Add references to all vertices to the 3D array _hanan_grid, in
 * correspondence with their (x,y,z)-position in the Hanan grid. */
Result Instance::SetHananGrid() {
    _hanan_grid = (Vertex****) calloc(_nx, sizeof(Vertex***));

    for (int i = 0; i < _nx; i++) {
        _hanan_grid[i] = (Vertex***) calloc(_ny, sizeof(Vertex**));
        for (int j = 0; j < _ny; j++) {
            _hanan_grid[i][j] = (Vertex**) calloc(_nz, sizeof(Vertex*));
            for (int k = 0; k < _nz; k++) {
                _hanan_grid[i][j][k] = _V[i*_ny*_nz + j*_nz + k];
            }
        }
    }
    return SUCCESS;
}

/* Using the _hanan_grid, add references to each vertex's neighbours in
 * the Hanan Grid */
Result Instance::SetNeighbours() {
    for (int i = 0; i < _nx; i++) {
        for (int j = 0; j < _ny; j++) {
            for (int k = 0; k < _nz; k++) {
                Vertex *v = _hanan_grid[i][j][k];
                /* Add all grid-adjacent vertices as neighbours */
                if (i - 1 >= 0)
                    v->AddNeighbour(_hanan_grid[i-1][j][k]);
                if (i + 1 < _nx)
                    v->AddNeighbour(_hanan_grid[i+1][j][k]);
                if (j - 1 >= 0)
                    v->AddNeighbour(_hanan_grid[i][j-1][k]);
                if (j + 1 < _ny)
                    v->AddNeighbour(_hanan_grid[i][j+1][k]);
                if (k - 1 >= 0)
                    v->AddNeighbour(_hanan_grid[i][j][k-1]);
                if (k + 1 < _nz)
                    v->AddNeighbour(_hanan_grid[i][j][k+1]);
            }
        }
    }
    return SUCCESS;
}

vector<Vertex*> *Instance::GetV() { return &_V; }
Vertex **Instance::GetTerminals() { return _terminals; }
int Instance::GetNTerminals() { return _n_terminals; }
int Instance::GetNVertices() { return _n_vertices; }


void Instance::PrintTerminals() {
    for (int i = 0; i < _n_terminals; i++)
        _terminals[i]->Print();
}

void Instance::PrintVertices() {
    for (int i = 0; i < _n_vertices; i++)
        _V[i]->Print();
}
